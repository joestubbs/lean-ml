"""
Module to execute the Python snippets and compare to
the sequence values. To do this, run:
    from oeis import exec_all_oeis_python
    exec_all_oeis_python()
from within a python shell with a virtualenv activated that has python packages
pre-installed, including numpy, sympy, graphillion

"""

import json
import os
import re
import sys
import subprocess
from io import StringIO
import timeit
import contextlib


# A context manager for redirecting stdout when exec'ing Python functions
# associated with an OEIS sequence and collecting the output.
@contextlib.contextmanager
def stdoutIO(stdout=None):
    old = sys.stdout
    if stdout is None:
        stdout = StringIO()
    sys.stdout = stdout
    yield stdout
    sys.stdout = old


# Pre-processed data from OEIS -- this file is generate using the oeis.py script contained
# withing the sequencelib git repo.
OEIS_RESULTS_FILE = os.environ.get(
    "OEIS_RESULTS_FILE", os.path.expanduser("~/oeis_python_results_more.json")
)

# Path to an output file where this script should write its results
OEIS_LEAN_OUTPUT_FILE = os.environ.get(
    "OEIS_LEAN_OUTPUT_FILE", os.path.expanduser("~/oeis_lean_source_llama-3.3-70B.json")
)

OEIS_EXEC_OUTPUT_FILE = os.environ.get(
    "OEIS_EXEC_OUTPUT_FILE", os.path.expanduser("~/oeis_exec_output.json")
)


def get_python_src():
    """
    Load the OEIS sequences that have Python source implementations.
    """
    with open(OEIS_RESULTS_FILE, "r") as f:
        return json.load(f)


def exec_oeis_python(python_source):
    """
    Try to execute the python source code associated with an OEIS sequence.
    Returns the associated stdout.
    """

    try:
        result = subprocess.run(
            [sys.executable, "-c", python_source], capture_output=True, text=True
        )
        return result.stdout
    except Exception as e:
        return f"Got exception: {e}"


def parse_string_to_int_list(input_string):
    """
    Parses a string containing numbers in various formats into a list of integers.

    Args:
        input_string (str): The string to parse, potentially containing numbers
                            separated by spaces, commas, or other non-digit characters.

    Returns:
        list: A list of integers extracted from the input string.
    """
    # Use re.findall to find all sequences of one or more digits
    # The regex r'\d+' matches one or more digit characters.
    numbers_as_strings = re.findall(r"-?\d+", input_string)

    # Convert each extracted string to an integer using a list comprehension
    int_list = [int(num_str) for num_str in numbers_as_strings]

    return int_list


def compare_python_to_oeis_vals(python_output, actual_values):
    """
    Compares the output from exec'ing a python function related to an
    OEIS sequence with the actual values.

    `python_output` should be the output generated by exec_oeis_python. We assume
    this string can be converted to a list of integers.

    `actual_values` should already be a list of integers, as parsed from the oeis
    sequence file.
    """
    # first, try to convert python_output to a list of integers.
    try:
        python_values = parse_string_to_int_list(python_output)
    except Exception as e:
        print(f"Got exception from parsing; e: {e}")
        return (f"Error: {e}", 0)

    # check for exact equality:
    if python_values == actual_values:
        return ("Exact Equality", len(python_values))

    # check if Python has more values and matches the exact values in the OEIS:
    if len(python_values) > len(actual_values) and (
        python_values[: len(actual_values)] == actual_values
    ):
        return ("Exact Equality; more Python values", len(actual_values))

    # handle a special case of 0 python values:
    if len(python_values) == 0:
        return ("No matching values; Python list was empty", 0)

    # check for partial equality with all python values:
    if actual_values[: len(python_values)] == python_values:
        return ("Partial Equality; Python had fewer values", len(python_values))

    # check for initial matches:
    for idx, val in enumerate(python_values):
        if idx >= len(actual_values):
            return ("Exact Equality; more Python values", len(actual_values))
        if not val == actual_values[idx]:
            if idx > 0:
                return (f"Partial Equality; Python value disagreed at {idx}", idx)
            else:
                return ("No matching values", 0)


def get_oeis_exec_results_from_file():
    """
    Read the results of the OEIS Python exec processing from a previous run.
    """
    with open(OEIS_EXEC_OUTPUT_FILE, "r") as f:
        return json.load(f)


def write_oeis_exec_results_file(results):
    print(f"Writing final results to: {OEIS_EXEC_OUTPUT_FILE}")
    with open(OEIS_EXEC_OUTPUT_FILE, "w+") as r:
        r.write(json.dumps(results))


def exec_all_oeis_python(start_from_prev=True, tot_seqs_limit=500):
    """
    Function to try and execute the Python code associated with a set of OEIS sequences
    and compare results with the sequence values. This function writes the results
    to an output file.
    """
    results = {}
    if start_from_prev:
        results = get_oeis_exec_results_from_file()
    oeis_source = get_python_src()
    idx = 0
    errors = 0
    python_values_parsed = 0
    exact_matches = 0
    partial_matches = 0
    no_matches = 0
    start = timeit.default_timer()
    for seq_id, value in oeis_source.items():
        seq_start = timeit.default_timer()
        # skip A339566 for now, as it takes about 3 hours to run.
        if seq_id == "A339566":
            continue
        idx += 1
        if seq_id in results.keys():
            print(f"Skipping sequence {seq_id} as it was already in the results.")
            continue
        print(f"Processing sequence {seq_id}, number {idx} of {tot_seqs_limit}")
        try:
            python_src = value["python_src"]
            seq_desc = value["desc"]
        except KeyError as e:
            errors += 1
            print(f"Got Key error for sequence {seq_id}; error: {e}; skipping")
            continue
        # get the sequence values:
        values = value["values"]
        # exec the python:
        output = exec_oeis_python(python_source=python_src)
        if "Got exception" in output:
            # if we got an error getting the python output, we don't need
            # to actually try and compare it with the OEIS.. just error out.
            result = (f"Error: {output}", 0)
        else:
            # compare results
            # result is a tuple with a string and an integer index
            result = compare_python_to_oeis_vals(output, values)

        cur = timeit.default_timer()
        seq_time = cur - seq_start
        tot_time = cur - start
        results[seq_id] = {
            "seq_desc": seq_desc,
            "python_result": result[0],
            "python_match_idx": result[1],
            "time_for_sequence": seq_time,
        }
        if "Error" in result[0]:
            print(f"Error for sequence {seq_id}; Error: {result[0]}")
            errors += 1
        else:
            python_values_parsed += 1
        if "Exact Equality" in result[0]:
            exact_matches += 1
        elif "Partial Equality" in result[0]:
            partial_matches += 1
        elif "No matching values" in result[0]:
            no_matches += 1
        write_oeis_exec_results_file(results=results)
        print(f"Time to analyze sequence: {seq_time}")
        # print total run time every 10:
        if idx % 10 == 0:
            print(f"Total runtime so far: {tot_time}")
        if idx >= tot_seqs_limit:
            break
    # Report final results:
    print(f"Total sequences processed: {tot_seqs_limit}")
    print(f"Sequences that typed checked: {python_values_parsed}")
    print(f"Total errors: {errors}")
    print(f"Exact Matches: {exact_matches}")
    print(f"Partial Matches: {partial_matches}")
    print(f"No Matches: {no_matches}")
    print(f"Total run time: {tot_time}")


if __name__ == "__main__":
    exec_all_oeis_python()
